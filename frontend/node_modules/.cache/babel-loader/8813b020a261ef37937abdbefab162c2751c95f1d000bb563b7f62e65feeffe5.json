{"ast":null,"code":"// Direct API calls to external fire data APIs (bypassing Flask backend)\n\nconst calcCenter = (coordinates, geomType) => {\n  let allCoords = [];\n  if (geomType === \"Polygon\") {\n    allCoords = coordinates[0];\n  } else if (geomType === \"MultiPolygon\") {\n    for (const polygon of coordinates) {\n      allCoords = allCoords.concat(polygon[0]);\n    }\n  }\n  if (!allCoords || allCoords.length === 0) {\n    return null;\n  }\n  const lngSum = allCoords.reduce((sum, coord) => sum + coord[0], 0);\n  const latSum = allCoords.reduce((sum, coord) => sum + coord[1], 0);\n  return [lngSum / allCoords.length, latSum / allCoords.length];\n};\nconst getSeverityFromSize = area => {\n  if (area >= 10000) {\n    return \"High\";\n  } else if (area >= 1000) {\n    return \"Medium\";\n  } else {\n    return \"Low\";\n  }\n};\nconst isAlaskaFire = (lat, lng) => {\n  // Alaska bounds (approximate)\n  const alaskaBounds = {\n    latMin: 51.0,\n    latMax: 72.0,\n    lngMin: -173.0,\n    lngMax: -130.0\n  };\n  return alaskaBounds.latMin <= lat && lat <= alaskaBounds.latMax && alaskaBounds.lngMin <= lng && lng <= alaskaBounds.lngMax;\n};\nconst getLatestFiresByName = features => {\n  const fireMap = {};\n  const cutoff = Date.now() - 24 * 60 * 60 * 1000; // last 24 hours only\n\n  for (const feature of features) {\n    var _fireMap$name$propert;\n    const properties = feature.properties || {};\n    const name = properties.poly_IncidentName || properties.incident_name;\n    const dateMs = properties.poly_DateCurrent || 0;\n    if (!name || dateMs < cutoff) {\n      continue;\n    }\n    if (!fireMap[name] || dateMs > (((_fireMap$name$propert = fireMap[name].properties) === null || _fireMap$name$propert === void 0 ? void 0 : _fireMap$name$propert.poly_DateCurrent) || 0)) {\n      fireMap[name] = feature;\n    }\n  }\n  return Object.values(fireMap);\n};\nexport const fetchRealTimeFireData = async () => {\n  try {\n    console.log(\"Fetching real-time fire data directly from ArcGIS API...\");\n    const apiUrl = \"https://services3.arcgis.com/T4QMspbfLg3qTGWY/arcgis/rest/services/WFIGS_Interagency_Perimeters_Current/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson\";\n    const headers = {\n      'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',\n      'Accept': 'application/json',\n      'Content-Type': 'application/json'\n    };\n    const response = await fetch(apiUrl, {\n      method: 'GET',\n      headers: headers,\n      mode: 'cors'\n    });\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const data = await response.json();\n    if (!data || data.type !== 'FeatureCollection') {\n      throw new Error('Invalid data format - expected FeatureCollection');\n    }\n    const features = data.features || [];\n    if (features.length === 0) {\n      console.log(\"No fire features found\");\n      return [];\n    }\n    const latestFeatures = getLatestFiresByName(features);\n    const processedFires = [];\n    for (let i = 0; i < latestFeatures.length; i++) {\n      console.log(`Processing feature ${i + 1}/${latestFeatures.length}`);\n      const feature = latestFeatures[i];\n      const geometry = feature.geometry || {};\n      const properties = feature.properties || {};\n      if (!geometry || !geometry.coordinates) {\n        console.log(`Skipping feature ${i + 1}: No valid geometry`);\n        continue;\n      }\n      const coords = geometry.coordinates;\n      const center = calcCenter(coords, geometry.type);\n      if (!center) {\n        console.log(`Skipping feature ${i + 1}: Could not calculate center`);\n        continue;\n      }\n      const incidentName = properties.poly_IncidentName || `Fire_${i + 1}`;\n      const epochMs = properties.poly_DateCurrent;\n      let lastUpdate = null;\n      if (epochMs) {\n        const epochS = epochMs / 1000;\n        const dt = new Date(epochS * 1000);\n        lastUpdate = dt.toISOString();\n      }\n      const area = Math.round(properties.poly_Acres_AutoCalc || 0);\n      const severity = getSeverityFromSize(area);\n      const fireData = {\n        id: properties.OBJECTID || `fire_${i + 1}`,\n        name: incidentName,\n        lat: center[1],\n        lng: center[0],\n        size: area,\n        containment: properties.poly_PercentContained,\n        severity: severity,\n        lastUpdate: lastUpdate,\n        weather: null,\n        // to be implemented\n        geometry: {\n          type: geometry.type,\n          coordinates: coords\n        }\n      };\n      processedFires.push(fireData);\n    }\n    console.log(`Successfully processed ${processedFires.length} fires`);\n\n    // Filter out Alaska fires\n    const filteredFires = processedFires.filter(fire => !isAlaskaFire(fire.lat, fire.lng));\n    const alaskaCount = processedFires.length - filteredFires.length;\n    console.log(`Filtered out ${alaskaCount} Alaska fires`);\n    console.log(`Returning ${filteredFires.length} fires`);\n    return filteredFires;\n  } catch (error) {\n    console.error('Failed to fetch fire data directly:', error);\n    throw error;\n  }\n};\n\n// Mock prediction service - replace with actual model API call\nexport const fetchPrediction = async (fireId, fireData) => {\n  if (!fireData) {\n    console.error('No fire data provided');\n    return null;\n  }\n\n  // Simulate API delay\n  await new Promise(resolve => setTimeout(resolve, 2000));\n\n  // Mock data - replace with actual model prediction\n  const mockPrediction = {\n    fireId: fireId,\n    predictionDate: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),\n    estimatedSize: fireData.size * (1.2 + Math.random() * 0.8),\n    confidence: Math.floor(Math.random() * 20) + 75,\n    riskLevel: Math.random() > 0.5 ? 'High' : 'Critical',\n    perimeter: [[fireData.lat + 0.01, fireData.lng + 0.01], [fireData.lat + 0.02, fireData.lng + 0.005], [fireData.lat + 0.015, fireData.lng - 0.01], [fireData.lat - 0.005, fireData.lng - 0.015], [fireData.lat - 0.01, fireData.lng + 0.005]]\n  };\n  return mockPrediction;\n};","map":{"version":3,"names":["calcCenter","coordinates","geomType","allCoords","polygon","concat","length","lngSum","reduce","sum","coord","latSum","getSeverityFromSize","area","isAlaskaFire","lat","lng","alaskaBounds","latMin","latMax","lngMin","lngMax","getLatestFiresByName","features","fireMap","cutoff","Date","now","feature","_fireMap$name$propert","properties","name","poly_IncidentName","incident_name","dateMs","poly_DateCurrent","Object","values","fetchRealTimeFireData","console","log","apiUrl","headers","response","fetch","method","mode","ok","Error","status","data","json","type","latestFeatures","processedFires","i","geometry","coords","center","incidentName","epochMs","lastUpdate","epochS","dt","toISOString","Math","round","poly_Acres_AutoCalc","severity","fireData","id","OBJECTID","size","containment","poly_PercentContained","weather","push","filteredFires","filter","fire","alaskaCount","error","fetchPrediction","fireId","Promise","resolve","setTimeout","mockPrediction","predictionDate","estimatedSize","random","confidence","floor","riskLevel","perimeter"],"sources":["/home/turtle09/FlameFlux/frontend/src/services/fireApiDirect.js"],"sourcesContent":["// Direct API calls to external fire data APIs (bypassing Flask backend)\n\nconst calcCenter = (coordinates, geomType) => {\n  let allCoords = [];\n  \n  if (geomType === \"Polygon\") {\n    allCoords = coordinates[0];\n  } else if (geomType === \"MultiPolygon\") {\n    for (const polygon of coordinates) {\n      allCoords = allCoords.concat(polygon[0]);\n    }\n  }\n\n  if (!allCoords || allCoords.length === 0) {\n    return null;\n  }\n\n  const lngSum = allCoords.reduce((sum, coord) => sum + coord[0], 0);\n  const latSum = allCoords.reduce((sum, coord) => sum + coord[1], 0);\n  \n  return [lngSum / allCoords.length, latSum / allCoords.length];\n};\n\nconst getSeverityFromSize = (area) => {\n  if (area >= 10000) {\n    return \"High\";\n  } else if (area >= 1000) {\n    return \"Medium\";\n  } else {\n    return \"Low\";\n  }\n};\n\nconst isAlaskaFire = (lat, lng) => {\n  // Alaska bounds (approximate)\n  const alaskaBounds = {\n    latMin: 51.0,\n    latMax: 72.0,\n    lngMin: -173.0,\n    lngMax: -130.0\n  };\n  \n  return (alaskaBounds.latMin <= lat && lat <= alaskaBounds.latMax &&\n          alaskaBounds.lngMin <= lng && lng <= alaskaBounds.lngMax);\n};\n\nconst getLatestFiresByName = (features) => {\n  const fireMap = {};\n  const cutoff = Date.now() - (24 * 60 * 60 * 1000); // last 24 hours only\n  \n  for (const feature of features) {\n    const properties = feature.properties || {};\n    const name = properties.poly_IncidentName || properties.incident_name;\n    const dateMs = properties.poly_DateCurrent || 0;\n    \n    if (!name || dateMs < cutoff) {\n      continue;\n    }\n\n    if (!fireMap[name] || dateMs > (fireMap[name].properties?.poly_DateCurrent || 0)) {\n      fireMap[name] = feature;\n    }\n  }\n  \n  return Object.values(fireMap);\n};\n\nexport const fetchRealTimeFireData = async () => {\n  try {\n    console.log(\"Fetching real-time fire data directly from ArcGIS API...\");\n    \n    const apiUrl = \"https://services3.arcgis.com/T4QMspbfLg3qTGWY/arcgis/rest/services/WFIGS_Interagency_Perimeters_Current/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson\";\n    \n    const headers = {\n      'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',\n      'Accept': 'application/json',\n      'Content-Type': 'application/json'\n    };\n    \n    const response = await fetch(apiUrl, {\n      method: 'GET',\n      headers: headers,\n      mode: 'cors'\n    });\n    \n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    \n    const data = await response.json();\n    \n    if (!data || data.type !== 'FeatureCollection') {\n      throw new Error('Invalid data format - expected FeatureCollection');\n    }\n\n    const features = data.features || [];\n    if (features.length === 0) {\n      console.log(\"No fire features found\");\n      return [];\n    }\n\n    const latestFeatures = getLatestFiresByName(features);\n    const processedFires = [];\n\n    for (let i = 0; i < latestFeatures.length; i++) {\n      console.log(`Processing feature ${i + 1}/${latestFeatures.length}`);\n      \n      const feature = latestFeatures[i];\n      const geometry = feature.geometry || {};\n      const properties = feature.properties || {};\n      \n      if (!geometry || !geometry.coordinates) {\n        console.log(`Skipping feature ${i + 1}: No valid geometry`);\n        continue;\n      }\n      \n      const coords = geometry.coordinates;\n      const center = calcCenter(coords, geometry.type);\n      \n      if (!center) {\n        console.log(`Skipping feature ${i + 1}: Could not calculate center`);\n        continue;\n      }\n\n      const incidentName = properties.poly_IncidentName || `Fire_${i + 1}`;\n      const epochMs = properties.poly_DateCurrent;\n      let lastUpdate = null;\n      \n      if (epochMs) {\n        const epochS = epochMs / 1000;\n        const dt = new Date(epochS * 1000);\n        lastUpdate = dt.toISOString();\n      }\n\n      const area = Math.round(properties.poly_Acres_AutoCalc || 0);\n      const severity = getSeverityFromSize(area);\n\n      const fireData = {\n        id: properties.OBJECTID || `fire_${i + 1}`,\n        name: incidentName,\n        lat: center[1],\n        lng: center[0],\n        size: area,\n        containment: properties.poly_PercentContained,\n        severity: severity,\n        lastUpdate: lastUpdate,\n        weather: null, // to be implemented\n        geometry: {\n          type: geometry.type,\n          coordinates: coords\n        }\n      };\n      \n      processedFires.push(fireData);\n    }\n\n    console.log(`Successfully processed ${processedFires.length} fires`);\n    \n    // Filter out Alaska fires\n    const filteredFires = processedFires.filter(fire => !isAlaskaFire(fire.lat, fire.lng));\n    const alaskaCount = processedFires.length - filteredFires.length;\n    console.log(`Filtered out ${alaskaCount} Alaska fires`);\n    \n    console.log(`Returning ${filteredFires.length} fires`);\n    return filteredFires;\n    \n  } catch (error) {\n    console.error('Failed to fetch fire data directly:', error);\n    throw error;\n  }\n};\n\n// Mock prediction service - replace with actual model API call\nexport const fetchPrediction = async (fireId, fireData) => {\n  if (!fireData) {\n    console.error('No fire data provided');\n    return null;\n  }\n  \n  // Simulate API delay\n  await new Promise(resolve => setTimeout(resolve, 2000));\n  \n  // Mock data - replace with actual model prediction\n  const mockPrediction = {\n    fireId: fireId,\n    predictionDate: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),\n    estimatedSize: fireData.size * (1.2 + Math.random() * 0.8),\n    confidence: Math.floor(Math.random() * 20) + 75,\n    riskLevel: Math.random() > 0.5 ? 'High' : 'Critical',\n    perimeter: [\n      [fireData.lat + 0.01, fireData.lng + 0.01],\n      [fireData.lat + 0.02, fireData.lng + 0.005],\n      [fireData.lat + 0.015, fireData.lng - 0.01],\n      [fireData.lat - 0.005, fireData.lng - 0.015],\n      [fireData.lat - 0.01, fireData.lng + 0.005]\n    ]\n  };\n  \n  return mockPrediction;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}