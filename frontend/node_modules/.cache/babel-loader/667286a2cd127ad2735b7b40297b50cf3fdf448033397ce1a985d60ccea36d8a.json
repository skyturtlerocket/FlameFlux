{"ast":null,"code":"// Utility functions for the wildfire dashboard\n\nexport const getSeverityColor = severity => {\n  switch (severity) {\n    case 'High':\n      return 'text-red-400';\n    case 'Medium':\n      return 'text-orange-400';\n    case 'Low':\n      return 'text-yellow-400';\n    default:\n      return 'text-gray-400';\n  }\n};\nexport const getSeverityColorHex = severity => {\n  switch (severity) {\n    case 'High':\n      return '#ef4444';\n    case 'Medium':\n      return '#f97316';\n    case 'Low':\n      return '#eab308';\n    default:\n      return '#6b7280';\n  }\n};\nexport const getSeverityBackgroundColor = severity => {\n  switch (severity) {\n    case 'High':\n      return '#ef4444';\n    case 'Medium':\n      return '#f97316';\n    case 'Low':\n    default:\n      return '#eab308';\n  }\n};\nexport const getIconSizeForSeverity = severity => {\n  switch (severity) {\n    case 'High':\n      return {\n        size: 48,\n        fontSize: '24px'\n      };\n    case 'Medium':\n      return {\n        size: 36,\n        fontSize: '18px'\n      };\n    case 'Low':\n    default:\n      return {\n        size: 24,\n        fontSize: '12px'\n      };\n  }\n};\nexport const formatDate = isoString => {\n  if (!isoString) return 'N/A';\n  return new Date(isoString).toLocaleString();\n};\nexport const getTileUrl = layer => {\n  switch (layer) {\n    case 'satellite':\n      return 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}';\n    case 'terrain':\n      return 'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png';\n    default:\n      return 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';\n  }\n};\n\n// Convert fire name to CSV filename format\nexport const convertFireNameToCSV = fireName => {\n  if (!fireName) return null;\n\n  // Remove leading/trailing whitespace and replace internal spaces with underscores\n  return fireName.trim().replace(/\\s+/g, '_');\n};\n\n// Get probability color based on predicted_prob value\nexport const getProbabilityColor = probability => {\n  // Ensure probability is between 0.5 and 1.0\n  const p = Math.max(0.5, Math.min(1.0, probability));\n\n  // Interpolate between yellow (p=0.5) and red (p=1.0)\n  const ratio = (p - 0.5) / 0.5; // 0 to 1\n\n  // Yellow: rgb(255, 255, 0) to Red: rgb(255, 0, 0)\n  const red = 255;\n  const green = Math.round(255 * (1 - ratio));\n  const blue = 0;\n  return `rgb(${red}, ${green}, ${blue})`;\n};\n\n// Load CSV data for a specific fire\nexport const loadFirePredictionCSV = async fireName => {\n  try {\n    const csvFileName = convertFireNameToCSV(fireName);\n    if (!csvFileName) {\n      throw new Error('Invalid fire name');\n    }\n\n    // Fetch the CSV file directly from the public directory\n    const response = await fetch(`/csv/${csvFileName}.csv`);\n\n    // If the file isn't found, return null so callers treat it as \"no data\"\n    if (!response.ok) {\n      throw new Error(`CSV file not found: ${csvFileName}.csv`);\n    }\n\n    // Do a lightweight validation: ensure the response looks like CSV and not HTML\n    const contentType = response.headers && response.headers.get && response.headers.get('content-type') || '';\n    const text = await response.text();\n    const firstLine = (text.split('\\n')[0] || '').toLowerCase();\n    const isCSVType = contentType.includes('text/csv') || contentType.includes('application/csv') || contentType.includes('application/octet-stream');\n    const hasHeader = firstLine.includes('predicted_prob') || firstLine.includes('lat') && firstLine.includes('lon') || firstLine.includes('predicted_prob');\n\n    // If it doesn't appear to be CSV (for example dev server returning index.html), treat as not found\n    if (!isCSVType && !hasHeader) {\n      throw new Error(`Fetched resource is not a CSV for ${csvFileName}.csv`);\n    }\n\n    // Parse CSV\n    const csvText = text;\n    const lines = csvText.split('\\n');\n    const headers = lines[0].split(',');\n    const data = [];\n    for (let i = 1; i < lines.length; i++) {\n      if (lines[i].trim()) {\n        const values = lines[i].split(',');\n        const row = {};\n        headers.forEach((header, index) => {\n          var _values$index;\n          row[header.trim()] = (_values$index = values[index]) === null || _values$index === void 0 ? void 0 : _values$index.trim();\n        });\n        data.push(row);\n      }\n    }\n    return data;\n  } catch (error) {\n    console.error(`Failed to load CSV for fire ${fireName}:`, error);\n    return null;\n  }\n};\n\n// Cache for prediction CSV existence checks to avoid repeated network calls\nconst csvExistenceCache = new Map();\n\n// Check if a prediction CSV exists for a given fire name\nexport const hasPredictionCSV = async fireName => {\n  const csvFileName = convertFireNameToCSV(fireName);\n  if (!csvFileName) return false;\n  if (csvExistenceCache.has(csvFileName)) {\n    return csvExistenceCache.get(csvFileName);\n  }\n  try {\n    const response = await fetch(`/csv/${csvFileName}.csv`, {\n      method: 'GET'\n    });\n    if (!response.ok) {\n      csvExistenceCache.set(csvFileName, false);\n      return false;\n    }\n\n    // Validate content-type and a minimal CSV header\n    const contentType = response.headers && response.headers.get && response.headers.get('content-type') || '';\n    const isCSVType = contentType.includes('text/csv') || contentType.includes('application/csv') || contentType.includes('application/octet-stream');\n\n    // Read just a small portion (dev servers may not support partial reads easily; read full then slice header)\n    const text = await response.text();\n    const firstLine = (text.split('\\n')[0] || '').toLowerCase();\n    const hasHeader = firstLine.includes('predicted_prob') || firstLine.includes('lat,') || firstLine.includes('lon');\n    const exists = isCSVType && hasHeader;\n    csvExistenceCache.set(csvFileName, exists);\n    return exists;\n  } catch (e) {\n    csvExistenceCache.set(csvFileName, false);\n    return false;\n  }\n};","map":{"version":3,"names":["getSeverityColor","severity","getSeverityColorHex","getSeverityBackgroundColor","getIconSizeForSeverity","size","fontSize","formatDate","isoString","Date","toLocaleString","getTileUrl","layer","convertFireNameToCSV","fireName","trim","replace","getProbabilityColor","probability","p","Math","max","min","ratio","red","green","round","blue","loadFirePredictionCSV","csvFileName","Error","response","fetch","ok","contentType","headers","get","text","firstLine","split","toLowerCase","isCSVType","includes","hasHeader","csvText","lines","data","i","length","values","row","forEach","header","index","_values$index","push","error","console","csvExistenceCache","Map","hasPredictionCSV","has","method","set","exists","e"],"sources":["/Users/timothyha/firecast/frontend/src/utils/helpers.js"],"sourcesContent":["// Utility functions for the wildfire dashboard\n\nexport const getSeverityColor = (severity) => {\n    switch (severity) {\n      case 'High': return 'text-red-400';\n      case 'Medium': return 'text-orange-400';\n      case 'Low': return 'text-yellow-400';\n      default: return 'text-gray-400';\n    }\n  };\n  \n  export const getSeverityColorHex = (severity) => {\n    switch (severity) {\n      case 'High': return '#ef4444';\n      case 'Medium': return '#f97316';\n      case 'Low': return '#eab308';\n      default: return '#6b7280';\n    }\n  };\n  \n  export const getSeverityBackgroundColor = (severity) => {\n    switch (severity) {\n      case 'High': return '#ef4444';\n      case 'Medium': return '#f97316';\n      case 'Low':\n      default: return '#eab308';\n    }\n  };\n  \n  export const getIconSizeForSeverity = (severity) => {\n    switch (severity) {\n      case 'High':\n        return { size: 48, fontSize: '24px' };\n      case 'Medium':\n        return { size: 36, fontSize: '18px' };\n      case 'Low':\n      default:\n        return { size: 24, fontSize: '12px' };\n    }\n  };\n  \n  export const formatDate = (isoString) => {\n    if (!isoString) return 'N/A';\n    return new Date(isoString).toLocaleString();\n  };\n  \n  export const getTileUrl = (layer) => {\n    switch (layer) {\n      case 'satellite':\n        return 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}';\n      case 'terrain':\n        return 'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png';\n      default:\n        return 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';\n    }\n  };\n\n// Convert fire name to CSV filename format\nexport const convertFireNameToCSV = (fireName) => {\n  if (!fireName) return null;\n  \n  // Remove leading/trailing whitespace and replace internal spaces with underscores\n  return fireName.trim().replace(/\\s+/g, '_');\n};\n\n// Get probability color based on predicted_prob value\nexport const getProbabilityColor = (probability) => {\n  // Ensure probability is between 0.5 and 1.0\n  const p = Math.max(0.5, Math.min(1.0, probability));\n  \n  // Interpolate between yellow (p=0.5) and red (p=1.0)\n  const ratio = (p - 0.5) / 0.5; // 0 to 1\n  \n  // Yellow: rgb(255, 255, 0) to Red: rgb(255, 0, 0)\n  const red = 255;\n  const green = Math.round(255 * (1 - ratio));\n  const blue = 0;\n  \n  return `rgb(${red}, ${green}, ${blue})`;\n};\n\n// Load CSV data for a specific fire\nexport const loadFirePredictionCSV = async (fireName) => {\n  try {\n    const csvFileName = convertFireNameToCSV(fireName);\n    if (!csvFileName) {\n      throw new Error('Invalid fire name');\n    }\n    \n    // Fetch the CSV file directly from the public directory\n    const response = await fetch(`/csv/${csvFileName}.csv`);\n\n    // If the file isn't found, return null so callers treat it as \"no data\"\n    if (!response.ok) {\n      throw new Error(`CSV file not found: ${csvFileName}.csv`);\n    }\n\n    // Do a lightweight validation: ensure the response looks like CSV and not HTML\n    const contentType = (response.headers && response.headers.get && response.headers.get('content-type')) || '';\n    const text = await response.text();\n    const firstLine = (text.split('\\n')[0] || '').toLowerCase();\n\n    const isCSVType = contentType.includes('text/csv') || contentType.includes('application/csv') || contentType.includes('application/octet-stream');\n    const hasHeader = firstLine.includes('predicted_prob') || (firstLine.includes('lat') && firstLine.includes('lon')) || firstLine.includes('predicted_prob');\n\n    // If it doesn't appear to be CSV (for example dev server returning index.html), treat as not found\n    if (!isCSVType && !hasHeader) {\n      throw new Error(`Fetched resource is not a CSV for ${csvFileName}.csv`);\n    }\n\n    // Parse CSV\n    const csvText = text;\n    const lines = csvText.split('\\n');\n    const headers = lines[0].split(',');\n    const data = [];\n\n    for (let i = 1; i < lines.length; i++) {\n      if (lines[i].trim()) {\n        const values = lines[i].split(',');\n        const row = {};\n        headers.forEach((header, index) => {\n          row[header.trim()] = values[index]?.trim();\n        });\n        data.push(row);\n      }\n    }\n\n    return data;\n  } catch (error) {\n    console.error(`Failed to load CSV for fire ${fireName}:`, error);\n    return null;\n  }\n};\n\n// Cache for prediction CSV existence checks to avoid repeated network calls\nconst csvExistenceCache = new Map();\n\n// Check if a prediction CSV exists for a given fire name\nexport const hasPredictionCSV = async (fireName) => {\n  const csvFileName = convertFireNameToCSV(fireName);\n  if (!csvFileName) return false;\n\n  if (csvExistenceCache.has(csvFileName)) {\n    return csvExistenceCache.get(csvFileName);\n  }\n\n  try {\n    const response = await fetch(`/csv/${csvFileName}.csv`, { method: 'GET' });\n    if (!response.ok) {\n      csvExistenceCache.set(csvFileName, false);\n      return false;\n    }\n\n    // Validate content-type and a minimal CSV header\n    const contentType = (response.headers && response.headers.get && response.headers.get('content-type')) || '';\n    const isCSVType = contentType.includes('text/csv') || contentType.includes('application/csv') || contentType.includes('application/octet-stream');\n\n    // Read just a small portion (dev servers may not support partial reads easily; read full then slice header)\n    const text = await response.text();\n    const firstLine = (text.split('\\n')[0] || '').toLowerCase();\n    const hasHeader = firstLine.includes('predicted_prob') || firstLine.includes('lat,') || firstLine.includes('lon');\n\n    const exists = isCSVType && hasHeader;\n    csvExistenceCache.set(csvFileName, exists);\n    return exists;\n  } catch (e) {\n    csvExistenceCache.set(csvFileName, false);\n    return false;\n  }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}